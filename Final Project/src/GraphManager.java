import java.awt.Dimension;
import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Scanner;

import processing.core.PApplet;

import edu.uci.ics.jung.algorithms.layout.SpringLayout;
import edu.uci.ics.jung.graph.Graph;
import edu.uci.ics.jung.graph.UndirectedSparseGraph;
/**Creates a graph and layout using the JUNg framework
 * */
public class GraphManager {
	 public Graph graph;
	 public SpringLayout<Integer,Edge> layout;
	 public ArrayList<Node> nodes;
     public ArrayList<ArrayList<Edge>> edges;
     public ArrayList<ArrayList<Integer>> nodesWithEdges;
     PApplet parent;
     public int numTimeSlices;
     
     /**Creates a new graph manager which generates or parses and saves the data
      * necessary for drawing the dynamic graph
      * @param p processing applet for drawing the graph elements
      * @param dataFile name of the data file (if node positions are saved)
      *                 null if node positions should be generated
      * */
     public GraphManager(PApplet p,String dataFile){
    	 this.parent = p;
    	 this.graph = new UndirectedSparseGraph<Integer,Edge>();   
    	 if (dataFile == null){
    		 readVanDeBunt();
    		 generateGraphs();    
    	 }else{
    		 
    	 }
    		   	 
     }
     
     /**Uses the JUNG to generate a set of layouts for the graph at each time slice      
      * */
     public void generateGraphs(){
    	 ArrayList <Edge> allEdges;
    	 //for (int i=0;i<this.numTimeSlices;i++){
    		//Add the edges for the specific time slice
    		 allEdges = this.edges.get(1);
    		 if (allEdges!=null){
    			 for (int j=0;j<allEdges.size();j++){    				    	 
    	        	 this.graph.addEdge(j,allEdges.get(j).node1,allEdges.get(j).node2);
    			 }
    		 }
    		 
        	 this.layout = new SpringLayout <Integer,Edge>(this.graph);
             this.layout.setSize(new Dimension(700,700)); 
             saveNodePositions(0);  
             saveNodePositions(1);           
             
    	// }         
     }
     
     /** Writes each node's position (x,y) for every time slice to a file
      *  This information is saved because the force directed layout is random\
      *  The format of the file is:
      *  node number
      *  (x,y)   
      *  ... last time slice ..last node
      * */
     public void saveNodePositions_file(String fileName){
    	 
     }
     
     /**Saves the node positions generated by a graph layout in a class
      * variable, does not save the coordinates to a file
      * */
     public void saveNodePositions(int view){
	   	  Node currentNode;
	   	  for (int i=0;i<this.nodes.size();i++){
	   		  currentNode = this.nodes.get(i);	   		  
	   		  if (this.nodesWithEdges.get(view).contains(i)){	   	   			
		   	      currentNode.coords.add(new Coordinate((float) this.layout.getX(i),(float) this.layout.getY(i)));			       		  	
	   		  }else{	   			
	   			  currentNode.coords.add(null);
	   		  }
	   		 this.nodes.set(i, currentNode);	   		    		  
	   	  }   	  
     }
     /**Calls the display function for all nodes and edges, which will
      * render them onto the screen
      * */
     public void drawGraph(){
    	 
    	 for (int i = 0;i<this.nodes.size();i++){
    		   this.nodes.get(i).display(1);    	
    	  }    	  
    	
		 for (int row = 0;row<this.edges.get(1).size();row++){   	
			// System.out.println(this.edges.get(1).get(row).node1+" "+this.edges.get(1).get(row).node2);
  	          this.edges.get(1).get(row).display(this.nodes,1);    	  	    	        	   	
  	     }	    
     }
    
     /**Reads the text file containing time-varying data of undergraduate student's friendship
      * Originally used in an experiment by Van De Bunt (1999)
      * */
     public void readVanDeBunt(){
    	  String filename = "vanDeBunt_all.txt";
       	  Scanner scan;
       	  int time = 0;
       	  int nodeCounter = 0;
       	  int edgeCounter = 0;
       	  int node1, node2,newNode;
       	  Edge newEdge;
       	 
       	  this.nodes = new ArrayList<Node>();
       	  this.edges = new ArrayList <ArrayList<Edge>>();
       	  this.nodesWithEdges = new ArrayList <ArrayList<Integer>>();
       	  
       	  try {
       			scan = new Scanner(new File(filename));
       			while(scan.hasNext())
       			{   				
       				String line;
       				line = scan.nextLine();
       				String[] items = line.split(" ");
       				if (items[0].equals("time")){
       					time = Integer.parseInt(items[1]);
       					nodeCounter = 0;  
       					this.edges.add(new ArrayList <Edge>());
       				}else{
       					if (time==0){ //The first time stamp, create all 32 nodes        						
       						this.nodes.add(new Node(this.parent,nodeCounter,""+nodeCounter));	
       						this.graph.addVertex(nodeCounter);       						
       					}
       					//Find the edges for each time stamp					
       					parseLine_vanDeBunt(nodeCounter,time,items);       					
       					nodeCounter++;       					
       				}				
       			}	       			
       		} catch (FileNotFoundException e) {			
       			e.printStackTrace();
       		}  
       	  this.numTimeSlices = time;        	
     }
     /**Parses one line of the van de bunt data set and sets the edges
      * */
    public void parseLine_vanDeBunt(int nodeNumber, int time, String [] line){
    	Edge newEdge;    	    	
    	this.nodesWithEdges.add(new ArrayList<Integer>());
    	
    	for (int i=0;i<line.length;i++){
    		int relation = Integer.parseInt(line[i]);      		
    		if (i!= nodeNumber  &&(relation == 1 || relation==2)){ //Only consider best friend or friend relations as a connection     			
    			newEdge = new Edge (this.parent,0,i,nodeNumber);    			
    			this.edges.get(time).add(newEdge);   
    			if (!this.nodesWithEdges.get(time).contains(i)){
    				this.nodesWithEdges.get(time).add(i);
    			}
    			if (!this.nodesWithEdges.get(time).contains(nodeNumber)){
    				this.nodesWithEdges.get(time).add(nodeNumber);
    			}    			
    		}
    	}     	
    	
    }
	 
}
